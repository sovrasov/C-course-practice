### Реализация списка или вектора

Требуется реализовать либо односвязный список, либо вектор на языке C.
Варианты лабораторной заранее распределены между студентами (см. таблицы посещаемости). Если кто-то сделает не свой вариант, задание не принимается.

## Односвязный список
[Список](https://ru.wikipedia.org/wiki/Связный_список) является динамческой структурой данных, состоящей из звеньев одного типа, связанных между собой указателями. Каждое звено будем представлять в виде структуры, которая содержит указатель на следующий элемент и, в общем случае, указатель типа `void*`, который представляет элемент, хранимый в списке. `void*` может указывать на память произвольного типа, контроль над операциями с этим указателлем лежит на пользователе. В таком варанте каждое звено списка может хранить что угодно (массив, структуру и т.д.). Для простоты можно считать, что каждое звено хранит один `int` и вместо указателя сделать второй элемент звена просто целым числом.
```c
typedef struct listNode listNode;
struct  listNode {
  listNode* pNext;
  void* pData;
} listNode;
```

Начало списка --- указатель на первое звено. Если список пустой, то указатель нулевой. Все звенья хранятся в динамической памяти, которая выделяется под каждое звено отдельно.
Базовые операции над списком, которые необходимо реализовать в лабораторной:
- Создание списка из `n` элементов. Прототип: `listNode* createList(int size)`. Функция создаёт список требуемого размера и возвращает указатель на его голову.
- Удаление списка. Прототип: `void deleteList(listNode** pHead)`. Функция принимает адрес указателя на голову списка, удаляет все звенья списка и зануляет значение указателя на голову.
-  Вставка элемента в список `listNode* insert(listNode* pNode)`. Функция создаёт новое звено вставляет его в список после заданного, возвращает указатель на новое звено.
- Удаление элемента из списка `void delete(listNode* pNode)`. Функция удаляет элемент, следующий для заданного элемента.
- Поиск элемента с заданным значением. Для простоты будем считать, что значение это указатель `void*` (или `int`). Прототип: `listNode* find(void* elem)`.

Список возможных функций неполный. Можно его дополнить по своему желанию.

Кроме списка необходимо написать программу, которая его использует. В простейшем случае это может быть просто создание списка, печать элементов, а потом демонстрация всех реализованных операций. Желательно, чтобы программа была многофайловой: заголовочный файл списка, реализация списка и реализация примера использования.

Дополнительно можно привети пример более содержательного использования списка. Например, отсортировать список.

## Вектор
[Вектор](https://ru.wikipedia.org/wiki/Vector_(C%2B%2B)) представляет из себя динамический массив переменной длины. Его длина может меняться в процессе работы, причём этот процесс скрыт от пользователя вектора. Достигается это за счёт того, что вектор всегда имеет два размера: пользовательский, который может менять ползователь и внутренний физический размер выделенной под вектор памяти. Будем представлять вектор с помощью следующей структуры:
```c
typedef struct  {
  void* pData;
  int elemSz;
  int size;

  int realMemSize; //real size of the allocated memory
} vector;
```
Для простоты можно считать, что `void*` это указатель на конкретный тип данных, тогда поле `elemSz` не нужно.
Задача программиста, который реализует вектор в том, чтобы вовремя перевыделять память при росте вектора и делать это как можно реже.

Базовые операции над вектором, которые необходимо реализовать в лабораторной:
- Создание вектора заданного размера. Прототип: `vector createVector(int elSz, int size)`. Функция выделяет `elSz*size` байт памяти под указатель `pData`, запоминает этот размер в `realMemSize` и устанавливает размер вектора, равным `size`.
- Удаление вектора. Прототип: `void deleteVector(vector* vec)`. Функция принимает указатель на вектор, освобождает память из `pData` и зануляет все поля переданной структуры.

- Вставка элемента в конец вектора. Прототип: `void push_back_vector(vector* vec, void* elem)`. Вместо `void* elem` может быть не указатель, а переменная конкретного типа (если изначально выбран упрощённый вариант). Функция вставляет заданный элемент в конец вектора, и, если это необходимо, предварительно увеличивает размер физичеккой памяти. Пользовательский размер вектора увеличивается на 1. Если физической памяти не хватает, необходимо выделить новую память и здесь можно нарастить память больше, чем на один новый элемент, чтобы избежать переаллокации при следующей вставке.

- Удаление произвольного элемента из вектора. Прототип: `void delete_from_vector(int position)`. Функция удаляет элемент на заданной позиции путём передвигания всех элементов, стоящих после него на одну позицию влево. Пользовательский размер вектора уменьшается на 1.

Так же как и со списком, требуется привести пример использования всех реализованнх операций с вектором.

Дополнительно можно реализовать и другие операции, а также более содержательный пример использования, в котором эксплуатируется именно динамически изменямый размер вектора.
