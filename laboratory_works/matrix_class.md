# Реализация класса для представления матриц

В этой лабораторной работе требуется реализовать класс для представления вещественных матриц и выполнения операций с ними.
Класс должен хранить матрицу типа `double` в виде одномерноого массива или массива массивов.

## Требования к API
### Конструкторы и деструктор
 - `Mat(int m, int n)` - создаёт матрицу указанных размеров.
 - `Mat(std::vector<double> vec)` - создаёт матрицу размера `vec.size() x 1`и заполняет её элементами вектора.
 - `Mat(const double* mem, int m)` - создаёт матрицу размеров `m x 1`, заполняя её данными из массива.
 - `Mat(const Mat& other)` - создаёт матрицу тех же размеров, что и `b` и копирует в неё данные из `other`. Созданная матрица и матрица `other` должны иметь одинаковые размеры и значения, и использовать различные указатели для хранения данных.
 - `Mat()` - создаёт пустую матрицу размера `0 x 0`.
 - `~Mat()` - освобождает память, выделенную под матрицу, если она не пустая.


### Методы
 - `std::pair<int, int> size() const` - возвращает размеры матрицы.
 - `const double& get(int i, int j)` - возвращает ссылку на элемент с индексами `i, j`. Индексация элементов начинается с 0.
 - `double* data(int i)` - возвращает указатель на начало i-ой строки.
 - `norm()` - возвращает Фробениосову норму матрицы.
 - `uniform_()` - заполняет матрицу случайными числами, равномерно распределёнными в дапазаоне [0;1].

### Перегруженные операторы
 - `Mat& operator=(const Mat& other)` - оператор присваивания. Копирует матрицу `other` в текущую и возвращает ссылку на текущую матрицу. Процедура копирования та же, что в конструкторе копирования, только здесть потребуется сначала освободить память текущей матрицы, если её размеры не совпадают с `other`, а затем выделить память подходящего размера и скопировать в неё данные.
 - `std::ostream& operator<<(std::ostream& os, const Mat& obj)` - вывод матрицы в поток. Возввращается ссылка не этот же поток.
 - `bool operator==(const Mat& lhs, const Mat& rhs)` - оператор, проверяющий поэлементное равенство матриц.
 - `bool operator!=(const Mat& lhs, const Mat& rhs)` - отрицание предыдущего оператора.
 - `Mat operator+(const Mat& lhs, const Mat& rhs)` - сложение матриц.
 - `Mat operator-(const Mat& lhs, const Mat& rhs)` - вычитание матриц.
 - `Mat operator*(const Mat& lhs, const Mat& rhs)` - умножение матриц.
 - `Mat operator*(const Mat& lhs, const double alpha)` - умножение матрицы на константу.

#### Примечания:
 - Все бинарные операторы должны возвращать новую матрицу, которая является результатом выполнения бинароной операции.
 - Вместо `std::pair<int, int>` можно использовать свою структуру для представления размера. Также в `C++ 11` есть возможность сделать алиас для типа и использовать тип по новому инени: `using Size = std::pair<int, int>;`
 - Релизация класса должна быть отделена от его декларации, т.е. должно быть два файла: `.hpp` для декларации и `.cpp` для реализации.
 - В случае, если совершить какую-либо операцию невозможно (например, размеры матриц для сложения разные), соответствующий оператор должен генерировать исключение.
 - Конструкторы также должны генерировать исключение в случае некорректных входных данных.

#### Пример генерации и обработки исключения:
```c++
#include <stdexcept>
#include <iostream>
void throw_error_if_zero(int i)  {
  if (i == 0)
    throw std::runtime_error("Zero input value!");
}
int main() {
  try {
    throw_error_if_zero(0);
  }
  catch(const std::runtime_error& exp)  {
    std::cout << exp.what() << std::endl;
  }
  return 0;
}
```
## Дополнительные требования
 - Сделать класс матриц шаблонным. Допустимый параметр шаблона - любой числовой тип C++.
 - Реализовать функцию для решения уравнений вида `A*x=b`, где `x, b` - векторы-столюбы, `A` - невырожденная квадратная матрица. Прототип: `Mat<T> solve (const Mat<T>& A, const Mat<T>& b)`. Функция должна возвращать `x`, если решение существует или пустую матрицу в противном случае. Стоит обратить внимание, что решить уравнение в общем случае возможно только над полем вещественных чисел, и это надо предусмотреть. Для этого можно использовать механизм проверки типов на этапе компиляции.

### Статическая проверка типа
```c++
#include <type_traits>
template <typename T>
void dummy() {
  static_assert(std::is_floating_point<T>::value);
}
int main() {
  dummy<int>();
  return 0;
}
```
## Тестирование функциональности
**TBD**
